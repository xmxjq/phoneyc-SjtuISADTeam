#!/usr/bin/env python

#
# Generated Thu Mar 11 10:02:29 2010 by generateDS.py version 1.20c.
#

import sys
import getopt
from string import lower as str_lower
from xml.dom import minidom
from xml.dom import Node

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def format_string(self, input_data, input_name=''):
            return input_data
        def format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def format_boolean(self, input_data, input_name=''):
            return '%s' % input_data


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class urls(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, clientInfo=None, url=None):
        if clientInfo is None:
            self.clientInfo = []
        else:
            self.clientInfo = clientInfo
        if url is None:
            self.url = []
        else:
            self.url = url
    def factory(*args_, **kwargs_):
        if urls.subclass:
            return urls.subclass(*args_, **kwargs_)
        else:
            return urls(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clientInfo(self): return self.clientInfo
    def set_clientInfo(self, clientInfo): self.clientInfo = clientInfo
    def add_clientInfo(self, value): self.clientInfo.append(value)
    def insert_clientInfo(self, index, value): self.clientInfo[index] = value
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def add_url(self, value): self.url.append(value)
    def insert_url(self, index, value): self.url[index] = value
    def export(self, outfile, level, namespace_='', name_='urls', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='urls')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='urls'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='urls'):
        for clientInfo_ in self.clientInfo:
            clientInfo_.export(outfile, level, namespace_, name_='clientInfo')
        for url_ in self.url:
            url_.export(outfile, level, namespace_, name_='url')
    def hasContent_(self):
        if (
            self.clientInfo or
            self.url
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='urls'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('clientInfo=[\n')
        level += 1
        for clientInfo_ in self.clientInfo:
            showIndent(outfile, level)
            outfile.write('model_.clientInfo(\n')
            clientInfo_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('url=[\n')
        level += 1
        for url_ in self.url:
            showIndent(outfile, level)
            outfile.write('model_.url(\n')
            url_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'clientInfo':
            obj_ = clientInfo.factory()
            obj_.build(child_)
            self.clientInfo.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'url':
            obj_ = url.factory()
            obj_.build(child_)
            self.url.append(obj_)
# end class urls


class clientInfo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, ipAddress=None, commandLine=None, startTime=None, endTime=None):
        if version is None:
            self.version = []
        else:
            self.version = version
        if ipAddress is None:
            self.ipAddress = []
        else:
            self.ipAddress = ipAddress
        if commandLine is None:
            self.commandLine = []
        else:
            self.commandLine = commandLine
        if startTime is None:
            self.startTime = []
        else:
            self.startTime = startTime
        if endTime is None:
            self.endTime = []
        else:
            self.endTime = endTime
    def factory(*args_, **kwargs_):
        if clientInfo.subclass:
            return clientInfo.subclass(*args_, **kwargs_)
        else:
            return clientInfo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def add_version(self, value): self.version.append(value)
    def insert_version(self, index, value): self.version[index] = value
    def get_ipAddress(self): return self.ipAddress
    def set_ipAddress(self, ipAddress): self.ipAddress = ipAddress
    def add_ipAddress(self, value): self.ipAddress.append(value)
    def insert_ipAddress(self, index, value): self.ipAddress[index] = value
    def get_commandLine(self): return self.commandLine
    def set_commandLine(self, commandLine): self.commandLine = commandLine
    def add_commandLine(self, value): self.commandLine.append(value)
    def insert_commandLine(self, index, value): self.commandLine[index] = value
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def add_startTime(self, value): self.startTime.append(value)
    def insert_startTime(self, index, value): self.startTime[index] = value
    def get_endTime(self): return self.endTime
    def set_endTime(self, endTime): self.endTime = endTime
    def add_endTime(self, value): self.endTime.append(value)
    def insert_endTime(self, index, value): self.endTime[index] = value
    def export(self, outfile, level, namespace_='', name_='clientInfo', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='clientInfo')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='clientInfo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='clientInfo'):
        for version_ in self.version:
            showIndent(outfile, level)
            outfile.write('<%sversion>%s</%sversion>\n' % (namespace_, self.format_string(quote_xml(version_).encode(ExternalEncoding), input_name='version'), namespace_))
        for ipAddress_ in self.ipAddress:
            showIndent(outfile, level)
            outfile.write('<%sipAddress>%s</%sipAddress>\n' % (namespace_, self.format_string(quote_xml(ipAddress_).encode(ExternalEncoding), input_name='ipAddress'), namespace_))
        for commandLine_ in self.commandLine:
            showIndent(outfile, level)
            outfile.write('<%scommandLine>%s</%scommandLine>\n' % (namespace_, self.format_string(quote_xml(commandLine_).encode(ExternalEncoding), input_name='commandLine'), namespace_))
        for startTime_ in self.startTime:
            showIndent(outfile, level)
            outfile.write('<%sstartTime>%s</%sstartTime>\n' % (namespace_, self.format_string(quote_xml(startTime_).encode(ExternalEncoding), input_name='startTime'), namespace_))
        for endTime_ in self.endTime:
            showIndent(outfile, level)
            outfile.write('<%sendTime>%s</%sendTime>\n' % (namespace_, self.format_string(quote_xml(endTime_).encode(ExternalEncoding), input_name='endTime'), namespace_))
    def hasContent_(self):
        if (
            self.version or
            self.ipAddress or
            self.commandLine or
            self.startTime or
            self.endTime
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='clientInfo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('version=[\n')
        level += 1
        for version_ in self.version:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(version_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ipAddress=[\n')
        level += 1
        for ipAddress_ in self.ipAddress:
            showIndent(outfile, level)
            outfile.write('model_.xs_string(\n')
            ipAddress_.exportLiteral(outfile, level, name_='xs:string')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('commandLine=[\n')
        level += 1
        for commandLine_ in self.commandLine:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(commandLine_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('startTime=[\n')
        level += 1
        for startTime_ in self.startTime:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(startTime_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('endTime=[\n')
        level += 1
        for endTime_ in self.endTime:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(endTime_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'version':
            version_ = ''
            for text__content_ in child_.childNodes:
                version_ += text__content_.nodeValue
            self.version.append(version_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ipAddress':
            ipAddress_ = ''
            for text__content_ in child_.childNodes:
                ipAddress_ += text__content_.nodeValue
            self.ipAddress.append(ipAddress_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'commandLine':
            commandLine_ = ''
            for text__content_ in child_.childNodes:
                commandLine_ += text__content_.nodeValue
            self.commandLine.append(commandLine_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'startTime':
            startTime_ = ''
            for text__content_ in child_.childNodes:
                startTime_ += text__content_.nodeValue
            self.startTime.append(startTime_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'endTime':
            endTime_ = ''
            for text__content_ in child_.childNodes:
                endTime_ += text__content_.nodeValue
            self.endTime.append(endTime_)
# end class clientInfo


class url(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, urlString=None, referrer=None, httpStatus=None, httpRedirectedTo=None, serverHeaders=None, requestHeaders=None, error=None, disposition=None, output=None, dnsResolution=None, contents=None, outgoingLinks=None, kit=None, exploits=None, classifications=None):
        self.id = _cast(None, id)
        if urlString is None:
            self.urlString = []
        else:
            self.urlString = urlString
        if referrer is None:
            self.referrer = []
        else:
            self.referrer = referrer
        if httpStatus is None:
            self.httpStatus = []
        else:
            self.httpStatus = httpStatus
        if httpRedirectedTo is None:
            self.httpRedirectedTo = []
        else:
            self.httpRedirectedTo = httpRedirectedTo
        if serverHeaders is None:
            self.serverHeaders = []
        else:
            self.serverHeaders = serverHeaders
        if requestHeaders is None:
            self.requestHeaders = []
        else:
            self.requestHeaders = requestHeaders
        if error is None:
            self.error = []
        else:
            self.error = error
        if disposition is None:
            self.disposition = []
        else:
            self.disposition = disposition
        if output is None:
            self.output = []
        else:
            self.output = output
        if dnsResolution is None:
            self.dnsResolution = []
        else:
            self.dnsResolution = dnsResolution
        if contents is None:
            self.contents = []
        else:
            self.contents = contents
        if outgoingLinks is None:
            self.outgoingLinks = []
        else:
            self.outgoingLinks = outgoingLinks
        if kit is None:
            self.kit = []
        else:
            self.kit = kit
        if exploits is None:
            self.exploits = []
        else:
            self.exploits = exploits
        if classifications is None:
            self.classifications = []
        else:
            self.classifications = classifications
    def factory(*args_, **kwargs_):
        if url.subclass:
            return url.subclass(*args_, **kwargs_)
        else:
            return url(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_urlString(self): return self.urlString
    def set_urlString(self, urlString): self.urlString = urlString
    def add_urlString(self, value): self.urlString.append(value)
    def insert_urlString(self, index, value): self.urlString[index] = value
    def get_referrer(self): return self.referrer
    def set_referrer(self, referrer): self.referrer = referrer
    def add_referrer(self, value): self.referrer.append(value)
    def insert_referrer(self, index, value): self.referrer[index] = value
    def get_httpStatus(self): return self.httpStatus
    def set_httpStatus(self, httpStatus): self.httpStatus = httpStatus
    def add_httpStatus(self, value): self.httpStatus.append(value)
    def insert_httpStatus(self, index, value): self.httpStatus[index] = value
    def get_httpRedirectedTo(self): return self.httpRedirectedTo
    def set_httpRedirectedTo(self, httpRedirectedTo): self.httpRedirectedTo = httpRedirectedTo
    def add_httpRedirectedTo(self, value): self.httpRedirectedTo.append(value)
    def insert_httpRedirectedTo(self, index, value): self.httpRedirectedTo[index] = value
    def get_serverHeaders(self): return self.serverHeaders
    def set_serverHeaders(self, serverHeaders): self.serverHeaders = serverHeaders
    def add_serverHeaders(self, value): self.serverHeaders.append(value)
    def insert_serverHeaders(self, index, value): self.serverHeaders[index] = value
    def get_requestHeaders(self): return self.requestHeaders
    def set_requestHeaders(self, requestHeaders): self.requestHeaders = requestHeaders
    def add_requestHeaders(self, value): self.requestHeaders.append(value)
    def insert_requestHeaders(self, index, value): self.requestHeaders[index] = value
    def get_error(self): return self.error
    def set_error(self, error): self.error = error
    def add_error(self, value): self.error.append(value)
    def insert_error(self, index, value): self.error[index] = value
    def get_disposition(self): return self.disposition
    def set_disposition(self, disposition): self.disposition = disposition
    def add_disposition(self, value): self.disposition.append(value)
    def insert_disposition(self, index, value): self.disposition[index] = value
    def validate_disposition(self, value):
        # validate type disposition
        pass
    def get_output(self): return self.output
    def set_output(self, output): self.output = output
    def add_output(self, value): self.output.append(value)
    def insert_output(self, index, value): self.output[index] = value
    def get_dnsResolution(self): return self.dnsResolution
    def set_dnsResolution(self, dnsResolution): self.dnsResolution = dnsResolution
    def add_dnsResolution(self, value): self.dnsResolution.append(value)
    def insert_dnsResolution(self, index, value): self.dnsResolution[index] = value
    def get_contents(self): return self.contents
    def set_contents(self, contents): self.contents = contents
    def add_contents(self, value): self.contents.append(value)
    def insert_contents(self, index, value): self.contents[index] = value
    def get_outgoingLinks(self): return self.outgoingLinks
    def set_outgoingLinks(self, outgoingLinks): self.outgoingLinks = outgoingLinks
    def add_outgoingLinks(self, value): self.outgoingLinks.append(value)
    def insert_outgoingLinks(self, index, value): self.outgoingLinks[index] = value
    def get_kit(self): return self.kit
    def set_kit(self, kit): self.kit = kit
    def add_kit(self, value): self.kit.append(value)
    def insert_kit(self, index, value): self.kit[index] = value
    def get_exploits(self): return self.exploits
    def set_exploits(self, exploits): self.exploits = exploits
    def add_exploits(self, value): self.exploits.append(value)
    def insert_exploits(self, index, value): self.exploits[index] = value
    def get_classifications(self): return self.classifications
    def set_classifications(self, classifications): self.classifications = classifications
    def add_classifications(self, value): self.classifications.append(value)
    def insert_classifications(self, index, value): self.classifications[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def export(self, outfile, level, namespace_='', name_='url', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='url')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='url'):
        if self.id is not None:
            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='url'):
        for urlString_ in self.urlString:
            showIndent(outfile, level)
            outfile.write('<%surlString>%s</%surlString>\n' % (namespace_, self.format_string(quote_xml(urlString_).encode(ExternalEncoding), input_name='urlString'), namespace_))
        for referrer_ in self.referrer:
            showIndent(outfile, level)
            outfile.write('<%sreferrer>%s</%sreferrer>\n' % (namespace_, self.format_string(quote_xml(referrer_).encode(ExternalEncoding), input_name='referrer'), namespace_))
        for httpStatus_ in self.httpStatus:
            showIndent(outfile, level)
            outfile.write('<%shttpStatus>%s</%shttpStatus>\n' % (namespace_, self.format_float(httpStatus_, input_name='httpStatus'), namespace_))
        for httpRedirectedTo_ in self.httpRedirectedTo:
            showIndent(outfile, level)
            outfile.write('<%shttpRedirectedTo>%s</%shttpRedirectedTo>\n' % (namespace_, self.format_string(quote_xml(httpRedirectedTo_).encode(ExternalEncoding), input_name='httpRedirectedTo'), namespace_))
        for serverHeaders_ in self.serverHeaders:
            showIndent(outfile, level)
            outfile.write('<%sserverHeaders>%s</%sserverHeaders>\n' % (namespace_, self.format_string(quote_xml(serverHeaders_).encode(ExternalEncoding), input_name='serverHeaders'), namespace_))
        for requestHeaders_ in self.requestHeaders:
            showIndent(outfile, level)
            outfile.write('<%srequestHeaders>%s</%srequestHeaders>\n' % (namespace_, self.format_string(quote_xml(requestHeaders_).encode(ExternalEncoding), input_name='requestHeaders'), namespace_))
        for error_ in self.error:
            showIndent(outfile, level)
            outfile.write('<%serror>%s</%serror>\n' % (namespace_, self.format_string(quote_xml(error_).encode(ExternalEncoding), input_name='error'), namespace_))
        for disposition_ in self.disposition:
            showIndent(outfile, level)
            outfile.write('<%sdisposition>%s</%sdisposition>\n' % (namespace_, self.format_string(quote_xml(disposition_).encode(ExternalEncoding), input_name='disposition'), namespace_))
        for output_ in self.output:
            showIndent(outfile, level)
            outfile.write('<%soutput>%s</%soutput>\n' % (namespace_, self.format_string(quote_xml(output_).encode(ExternalEncoding), input_name='output'), namespace_))
        for dnsResolution_ in self.dnsResolution:
            dnsResolution_.export(outfile, level, namespace_, name_='dnsResolution')
        for contents_ in self.contents:
            contents_.export(outfile, level, namespace_, name_='contents')
        for outgoingLinks_ in self.outgoingLinks:
            outgoingLinks_.export(outfile, level, namespace_, name_='outgoingLinks')
        for kit_ in self.kit:
            kit_.export(outfile, level, namespace_, name_='kit')
        for exploits_ in self.exploits:
            exploits_.export(outfile, level, namespace_, name_='exploits')
        for classifications_ in self.classifications:
            classifications_.export(outfile, level, namespace_, name_='classifications')
    def hasContent_(self):
        if (
            self.urlString or
            self.referrer or
            self.httpStatus or
            self.httpRedirectedTo or
            self.serverHeaders or
            self.requestHeaders or
            self.error or
            self.disposition or
            self.output or
            self.dnsResolution or
            self.contents or
            self.outgoingLinks or
            self.kit or
            self.exploits or
            self.classifications
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='url'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('urlString=[\n')
        level += 1
        for urlString_ in self.urlString:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(urlString_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('referrer=[\n')
        level += 1
        for referrer_ in self.referrer:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(referrer_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('httpStatus=[\n')
        level += 1
        for httpStatus_ in self.httpStatus:
            showIndent(outfile, level)
            outfile.write('%f,\n' % httpStatus)
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('httpRedirectedTo=[\n')
        level += 1
        for httpRedirectedTo_ in self.httpRedirectedTo:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(httpRedirectedTo_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('serverHeaders=[\n')
        level += 1
        for serverHeaders_ in self.serverHeaders:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(serverHeaders_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('requestHeaders=[\n')
        level += 1
        for requestHeaders_ in self.requestHeaders:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(requestHeaders_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('error=[\n')
        level += 1
        for error_ in self.error:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(error_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('disposition=[\n')
        level += 1
        for disposition_ in self.disposition:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(disposition_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('output=[\n')
        level += 1
        for output_ in self.output:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(output_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('dnsResolution=[\n')
        level += 1
        for dnsResolution_ in self.dnsResolution:
            showIndent(outfile, level)
            outfile.write('model_.dnsResolution(\n')
            dnsResolution_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('contents=[\n')
        level += 1
        for contents_ in self.contents:
            showIndent(outfile, level)
            outfile.write('model_.contents(\n')
            contents_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('outgoingLinks=[\n')
        level += 1
        for outgoingLinks_ in self.outgoingLinks:
            showIndent(outfile, level)
            outfile.write('model_.outgoingLinks(\n')
            outgoingLinks_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('kit=[\n')
        level += 1
        for kit_ in self.kit:
            showIndent(outfile, level)
            outfile.write('model_.kit(\n')
            kit_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('exploits=[\n')
        level += 1
        for exploits_ in self.exploits:
            showIndent(outfile, level)
            outfile.write('model_.exploits(\n')
            exploits_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('classifications=[\n')
        level += 1
        for classifications_ in self.classifications:
            showIndent(outfile, level)
            outfile.write('model_.classifications(\n')
            classifications_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'urlString':
            urlString_ = ''
            for text__content_ in child_.childNodes:
                urlString_ += text__content_.nodeValue
            self.urlString.append(urlString_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'referrer':
            referrer_ = ''
            for text__content_ in child_.childNodes:
                referrer_ += text__content_.nodeValue
            self.referrer.append(referrer_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'httpStatus':
            if child_.firstChild:
                sval_ = child_.firstChild.nodeValue
                try:
                    fval_ = float(sval_)
                except ValueError, exp:
                    raise ValueError('requires float or double (httpStatus): %s' %exp)
                self.httpStatus.append(fval_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'httpRedirectedTo':
            httpRedirectedTo_ = ''
            for text__content_ in child_.childNodes:
                httpRedirectedTo_ += text__content_.nodeValue
            self.httpRedirectedTo.append(httpRedirectedTo_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'serverHeaders':
            serverHeaders_ = ''
            for text__content_ in child_.childNodes:
                serverHeaders_ += text__content_.nodeValue
            self.serverHeaders.append(serverHeaders_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'requestHeaders':
            requestHeaders_ = ''
            for text__content_ in child_.childNodes:
                requestHeaders_ += text__content_.nodeValue
            self.requestHeaders.append(requestHeaders_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'error':
            error_ = ''
            for text__content_ in child_.childNodes:
                error_ += text__content_.nodeValue
            self.error.append(error_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'disposition':
            disposition_ = ''
            for text__content_ in child_.childNodes:
                disposition_ += text__content_.nodeValue
            self.disposition.append(disposition_)
            self.validate_disposition(self.disposition)    # validate type disposition
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'output':
            output_ = ''
            for text__content_ in child_.childNodes:
                output_ += text__content_.nodeValue
            self.output.append(output_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'dnsResolution':
            obj_ = dnsResolution.factory()
            obj_.build(child_)
            self.dnsResolution.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'contents':
            obj_ = contents.factory()
            obj_.build(child_)
            self.contents.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'outgoingLinks':
            obj_ = outgoingLinks.factory()
            obj_.build(child_)
            self.outgoingLinks.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'kit':
            obj_ = kit.factory()
            obj_.build(child_)
            self.kit.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'exploits':
            obj_ = exploits.factory()
            obj_.build(child_)
            self.exploits.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'classifications':
            obj_ = classifications.factory()
            obj_.build(child_)
            self.classifications.append(obj_)
# end class url


class disposition(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, valueOf_=''):
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if disposition.subclass:
            return disposition.subclass(*args_, **kwargs_)
        else:
            return disposition(*args_, **kwargs_)
    factory = staticmethod(factory)
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='disposition', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='disposition')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='disposition'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='disposition'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='disposition'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class disposition


class dnsResolution(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hostname=None, resolvesTo=None):
        if hostname is None:
            self.hostname = []
        else:
            self.hostname = hostname
        if resolvesTo is None:
            self.resolvesTo = []
        else:
            self.resolvesTo = resolvesTo
    def factory(*args_, **kwargs_):
        if dnsResolution.subclass:
            return dnsResolution.subclass(*args_, **kwargs_)
        else:
            return dnsResolution(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hostname(self): return self.hostname
    def set_hostname(self, hostname): self.hostname = hostname
    def add_hostname(self, value): self.hostname.append(value)
    def insert_hostname(self, index, value): self.hostname[index] = value
    def get_resolvesTo(self): return self.resolvesTo
    def set_resolvesTo(self, resolvesTo): self.resolvesTo = resolvesTo
    def add_resolvesTo(self, value): self.resolvesTo.append(value)
    def insert_resolvesTo(self, index, value): self.resolvesTo[index] = value
    def export(self, outfile, level, namespace_='', name_='dnsResolution', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='dnsResolution')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='dnsResolution'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='dnsResolution'):
        for hostname_ in self.hostname:
            showIndent(outfile, level)
            outfile.write('<%shostname>%s</%shostname>\n' % (namespace_, self.format_string(quote_xml(hostname_).encode(ExternalEncoding), input_name='hostname'), namespace_))
        for resolvesTo_ in self.resolvesTo:
            resolvesTo_.export(outfile, level, namespace_, name_='resolvesTo')
    def hasContent_(self):
        if (
            self.hostname or
            self.resolvesTo
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='dnsResolution'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hostname=[\n')
        level += 1
        for hostname_ in self.hostname:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(hostname_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('resolvesTo=[\n')
        level += 1
        for resolvesTo_ in self.resolvesTo:
            showIndent(outfile, level)
            outfile.write('model_.resolvesTo(\n')
            resolvesTo_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hostname':
            hostname_ = ''
            for text__content_ in child_.childNodes:
                hostname_ += text__content_.nodeValue
            self.hostname.append(hostname_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'resolvesTo':
            obj_ = resolvesTo.factory()
            obj_.build(child_)
            self.resolvesTo.append(obj_)
# end class dnsResolution


class resolvesTo(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ipAddress=None, cname=None):
        if ipAddress is None:
            self.ipAddress = []
        else:
            self.ipAddress = ipAddress
        if cname is None:
            self.cname = []
        else:
            self.cname = cname
    def factory(*args_, **kwargs_):
        if resolvesTo.subclass:
            return resolvesTo.subclass(*args_, **kwargs_)
        else:
            return resolvesTo(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ipAddress(self): return self.ipAddress
    def set_ipAddress(self, ipAddress): self.ipAddress = ipAddress
    def add_ipAddress(self, value): self.ipAddress.append(value)
    def insert_ipAddress(self, index, value): self.ipAddress[index] = value
    def get_cname(self): return self.cname
    def set_cname(self, cname): self.cname = cname
    def add_cname(self, value): self.cname.append(value)
    def insert_cname(self, index, value): self.cname[index] = value
    def export(self, outfile, level, namespace_='', name_='resolvesTo', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='resolvesTo')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='resolvesTo'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='resolvesTo'):
        for ipAddress_ in self.ipAddress:
            ipAddress_.export(outfile, level, namespace_, name_='ipAddress')
        for cname_ in self.cname:
            cname_.export(outfile, level, namespace_, name_='cname')
    def hasContent_(self):
        if (
            self.ipAddress or
            self.cname
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='resolvesTo'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ipAddress=[\n')
        level += 1
        for ipAddress_ in self.ipAddress:
            showIndent(outfile, level)
            outfile.write('model_.ipAddress(\n')
            ipAddress_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('cname=[\n')
        level += 1
        for cname_ in self.cname:
            showIndent(outfile, level)
            outfile.write('model_.cname(\n')
            cname_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'ipAddress':
            obj_ = ipAddress.factory()
            obj_.build(child_)
            self.ipAddress.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'cname':
            obj_ = cname.factory()
            obj_.build(child_)
            self.cname.append(obj_)
# end class resolvesTo


class ipAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, timestamp=None, family=None, valueOf_=''):
        self.timestamp = _cast(None, timestamp)
        self.family = _cast(None, family)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ipAddress.subclass:
            return ipAddress.subclass(*args_, **kwargs_)
        else:
            return ipAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def get_family(self): return self.family
    def set_family(self, family): self.family = family
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='ipAddress', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='ipAddress')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='ipAddress'):
        if self.timestamp is not None:
            outfile.write(' timestamp=%s' % (self.format_string(quote_attrib(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), ))
        if self.family is not None:
            outfile.write(' family=%s' % (self.format_string(quote_attrib(self.family).encode(ExternalEncoding), input_name='family'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ipAddress'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ipAddress'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp = "%s",\n' % (self.timestamp,))
        if self.family is not None:
            showIndent(outfile, level)
            outfile.write('family = "%s",\n' % (self.family,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('timestamp'):
            self.timestamp = attrs.get('timestamp').value
        if attrs.get('family'):
            self.family = attrs.get('family').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class ipAddress


class cname(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, timestamp=None, valueOf_=''):
        self.timestamp = _cast(None, timestamp)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if cname.subclass:
            return cname.subclass(*args_, **kwargs_)
        else:
            return cname(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='cname', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='cname')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='cname'):
        if self.timestamp is not None:
            outfile.write(' timestamp=%s' % (self.format_string(quote_attrib(self.timestamp).encode(ExternalEncoding), input_name='timestamp'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='cname'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='cname'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.timestamp is not None:
            showIndent(outfile, level)
            outfile.write('timestamp = "%s",\n' % (self.timestamp,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('timestamp'):
            self.timestamp = attrs.get('timestamp').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class cname


class contents(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, content=None, content_type=None, content_length=None, hashes=None):
        if content is None:
            self.content = []
        else:
            self.content = content
        if content_type is None:
            self.content_type = []
        else:
            self.content_type = content_type
        if content_length is None:
            self.content_length = []
        else:
            self.content_length = content_length
        if hashes is None:
            self.hashes = []
        else:
            self.hashes = hashes
    def factory(*args_, **kwargs_):
        if contents.subclass:
            return contents.subclass(*args_, **kwargs_)
        else:
            return contents(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_content(self): return self.content
    def set_content(self, content): self.content = content
    def add_content(self, value): self.content.append(value)
    def insert_content(self, index, value): self.content[index] = value
    def get_content_type(self): return self.content_type
    def set_content_type(self, content_type): self.content_type = content_type
    def add_content_type(self, value): self.content_type.append(value)
    def insert_content_type(self, index, value): self.content_type[index] = value
    def get_content_length(self): return self.content_length
    def set_content_length(self, content_length): self.content_length = content_length
    def add_content_length(self, value): self.content_length.append(value)
    def insert_content_length(self, index, value): self.content_length[index] = value
    def get_hashes(self): return self.hashes
    def set_hashes(self, hashes): self.hashes = hashes
    def add_hashes(self, value): self.hashes.append(value)
    def insert_hashes(self, index, value): self.hashes[index] = value
    def export(self, outfile, level, namespace_='', name_='contents', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='contents')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='contents'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='contents'):
        for content_ in self.content:
            showIndent(outfile, level)
            outfile.write('<%scontent>%s</%scontent>\n' % (namespace_, self.format_string(quote_xml(content_).encode(ExternalEncoding), input_name='content'), namespace_))
        for content_type_ in self.content_type:
            showIndent(outfile, level)
            outfile.write('<%scontent_type>%s</%scontent_type>\n' % (namespace_, self.format_string(quote_xml(content_type_).encode(ExternalEncoding), input_name='content_type'), namespace_))
        for content_length_ in self.content_length:
            content_length_.export(outfile, level, namespace_, name_='content_length')
        for hashes_ in self.hashes:
            hashes_.export(outfile, level, namespace_, name_='hashes')
    def hasContent_(self):
        if (
            self.content or
            self.content_type or
            self.content_length or
            self.hashes
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='contents'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('content=[\n')
        level += 1
        for content_ in self.content:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(content_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_type=[\n')
        level += 1
        for content_type_ in self.content_type:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(content_type_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('content_length=[\n')
        level += 1
        for content_length_ in self.content_length:
            showIndent(outfile, level)
            outfile.write('model_.content_length(\n')
            content_length_.exportLiteral(outfile, level, name_='content-length')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('hashes=[\n')
        level += 1
        for hashes_ in self.hashes:
            showIndent(outfile, level)
            outfile.write('model_.hashes(\n')
            hashes_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'content':
            content_ = ''
            for text__content_ in child_.childNodes:
                content_ += text__content_.nodeValue
            self.content.append(content_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'content-type':
            content_type_ = ''
            for text__content_ in child_.childNodes:
                content_type_ += text__content_.nodeValue
            self.content_type.append(content_type_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'content-length':
            obj_ = content_length.factory()
            obj_.build(child_)
            self.content_length.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hashes':
            obj_ = hashes.factory()
            obj_.build(child_)
            self.hashes.append(obj_)
# end class contents


class content_length(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, units=None, valueOf_=''):
        self.units = _cast(None, units)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if content_length.subclass:
            return content_length.subclass(*args_, **kwargs_)
        else:
            return content_length(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_units(self): return self.units
    def set_units(self, units): self.units = units
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='content-length', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='content-length')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='content-length'):
        if self.units is not None:
            outfile.write(' units=%s' % (self.format_string(quote_attrib(self.units).encode(ExternalEncoding), input_name='units'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='content-length'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='content-length'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.units is not None:
            showIndent(outfile, level)
            outfile.write('units = "%s",\n' % (self.units,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('units'):
            self.units = attrs.get('units').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class content_length


class hashes(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, hash=None):
        if hash is None:
            self.hash = []
        else:
            self.hash = hash
    def factory(*args_, **kwargs_):
        if hashes.subclass:
            return hashes.subclass(*args_, **kwargs_)
        else:
            return hashes(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_hash(self): return self.hash
    def set_hash(self, hash): self.hash = hash
    def add_hash(self, value): self.hash.append(value)
    def insert_hash(self, index, value): self.hash[index] = value
    def export(self, outfile, level, namespace_='', name_='hashes', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='hashes')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='hashes'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='hashes'):
        for hash_ in self.hash:
            hash_.export(outfile, level, namespace_, name_='hash')
    def hasContent_(self):
        if (
            self.hash
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='hashes'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('hash=[\n')
        level += 1
        for hash_ in self.hash:
            showIndent(outfile, level)
            outfile.write('model_.hash(\n')
            hash_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'hash':
            obj_ = hash.factory()
            obj_.build(child_)
            self.hash.append(obj_)
# end class hashes


class hash(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, algorithm=None, valueOf_=''):
        self.algorithm = _cast(None, algorithm)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if hash.subclass:
            return hash.subclass(*args_, **kwargs_)
        else:
            return hash(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_algorithm(self): return self.algorithm
    def set_algorithm(self, algorithm): self.algorithm = algorithm
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='hash', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='hash')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='hash'):
        if self.algorithm is not None:
            outfile.write(' algorithm=%s' % (quote_attrib(self.algorithm), ))
    def exportChildren(self, outfile, level, namespace_='', name_='hash'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='hash'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.algorithm is not None:
            showIndent(outfile, level)
            outfile.write('algorithm = %s,\n' % (self.algorithm,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('algorithm'):
            self.algorithm = attrs.get('algorithm').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class hash


class outgoingLinks(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, link=None):
        if link is None:
            self.link = []
        else:
            self.link = link
    def factory(*args_, **kwargs_):
        if outgoingLinks.subclass:
            return outgoingLinks.subclass(*args_, **kwargs_)
        else:
            return outgoingLinks(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_link(self): return self.link
    def set_link(self, link): self.link = link
    def add_link(self, value): self.link.append(value)
    def insert_link(self, index, value): self.link[index] = value
    def export(self, outfile, level, namespace_='', name_='outgoingLinks', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='outgoingLinks')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='outgoingLinks'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='outgoingLinks'):
        for link_ in self.link:
            link_.export(outfile, level, namespace_, name_='link')
    def hasContent_(self):
        if (
            self.link
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='outgoingLinks'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('link=[\n')
        level += 1
        for link_ in self.link:
            showIndent(outfile, level)
            outfile.write('model_.link(\n')
            link_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'link':
            obj_ = link.factory()
            obj_.build(child_)
            self.link.append(obj_)
# end class outgoingLinks


class link(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, tag=None, valueOf_=''):
        self.tag = _cast(None, tag)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if link.subclass:
            return link.subclass(*args_, **kwargs_)
        else:
            return link(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_tag(self): return self.tag
    def set_tag(self, tag): self.tag = tag
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='link', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='link')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='link'):
        if self.tag is not None:
            outfile.write(' tag=%s' % (self.format_string(quote_attrib(self.tag).encode(ExternalEncoding), input_name='tag'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='link'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='link'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.tag is not None:
            showIndent(outfile, level)
            outfile.write('tag = "%s",\n' % (self.tag,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('tag'):
            self.tag = attrs.get('tag').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class link


class kit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, valueOf_=''):
        self.version = _cast(None, version)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if kit.subclass:
            return kit.subclass(*args_, **kwargs_)
        else:
            return kit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='kit', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='kit')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='kit'):
        if self.version is not None:
            outfile.write(' version=%s' % (self.format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='kit'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='kit'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version = "%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('version'):
            self.version = attrs.get('version').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class kit


class exploits(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, exploit=None):
        if exploit is None:
            self.exploit = []
        else:
            self.exploit = exploit
    def factory(*args_, **kwargs_):
        if exploits.subclass:
            return exploits.subclass(*args_, **kwargs_)
        else:
            return exploits(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_exploit(self): return self.exploit
    def set_exploit(self, exploit): self.exploit = exploit
    def add_exploit(self, value): self.exploit.append(value)
    def insert_exploit(self, index, value): self.exploit[index] = value
    def export(self, outfile, level, namespace_='', name_='exploits', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='exploits')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='exploits'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='exploits'):
        for exploit_ in self.exploit:
            exploit_.export(outfile, level, namespace_, name_='exploit')
    def hasContent_(self):
        if (
            self.exploit
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='exploits'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('exploit=[\n')
        level += 1
        for exploit_ in self.exploit:
            showIndent(outfile, level)
            outfile.write('model_.exploit(\n')
            exploit_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'exploit':
            obj_ = exploit.factory()
            obj_.build(child_)
            self.exploit.append(obj_)
# end class exploits


class exploit(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, shellcode=None, vulnerability=None, module=None, consequence=None):
        if shellcode is None:
            self.shellcode = []
        else:
            self.shellcode = shellcode
        if vulnerability is None:
            self.vulnerability = []
        else:
            self.vulnerability = vulnerability
        if module is None:
            self.module = []
        else:
            self.module = module
        if consequence is None:
            self.consequence = []
        else:
            self.consequence = consequence
    def factory(*args_, **kwargs_):
        if exploit.subclass:
            return exploit.subclass(*args_, **kwargs_)
        else:
            return exploit(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_shellcode(self): return self.shellcode
    def set_shellcode(self, shellcode): self.shellcode = shellcode
    def add_shellcode(self, value): self.shellcode.append(value)
    def insert_shellcode(self, index, value): self.shellcode[index] = value
    def get_vulnerability(self): return self.vulnerability
    def set_vulnerability(self, vulnerability): self.vulnerability = vulnerability
    def add_vulnerability(self, value): self.vulnerability.append(value)
    def insert_vulnerability(self, index, value): self.vulnerability[index] = value
    def get_module(self): return self.module
    def set_module(self, module): self.module = module
    def add_module(self, value): self.module.append(value)
    def insert_module(self, index, value): self.module[index] = value
    def get_consequence(self): return self.consequence
    def set_consequence(self, consequence): self.consequence = consequence
    def add_consequence(self, value): self.consequence.append(value)
    def insert_consequence(self, index, value): self.consequence[index] = value
    def export(self, outfile, level, namespace_='', name_='exploit', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='exploit')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='exploit'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='exploit'):
        for shellcode_ in self.shellcode:
            showIndent(outfile, level)
            outfile.write('<%sshellcode>%s</%sshellcode>\n' % (namespace_, self.format_string(quote_xml(shellcode_).encode(ExternalEncoding), input_name='shellcode'), namespace_))
        for vulnerability_ in self.vulnerability:
            vulnerability_.export(outfile, level, namespace_, name_='vulnerability')
        for module_ in self.module:
            module_.export(outfile, level, namespace_, name_='module')
        for consequence_ in self.consequence:
            consequence_.export(outfile, level, namespace_, name_='consequence')
    def hasContent_(self):
        if (
            self.shellcode or
            self.vulnerability or
            self.module or
            self.consequence
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='exploit'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('shellcode=[\n')
        level += 1
        for shellcode_ in self.shellcode:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(shellcode_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('vulnerability=[\n')
        level += 1
        for vulnerability_ in self.vulnerability:
            showIndent(outfile, level)
            outfile.write('model_.vulnerability(\n')
            vulnerability_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('module=[\n')
        level += 1
        for module_ in self.module:
            showIndent(outfile, level)
            outfile.write('model_.module(\n')
            module_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('consequence=[\n')
        level += 1
        for consequence_ in self.consequence:
            showIndent(outfile, level)
            outfile.write('model_.consequence(\n')
            consequence_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'shellcode':
            shellcode_ = ''
            for text__content_ in child_.childNodes:
                shellcode_ += text__content_.nodeValue
            self.shellcode.append(shellcode_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'vulnerability':
            obj_ = vulnerability.factory()
            obj_.build(child_)
            self.vulnerability.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'module':
            obj_ = module.factory()
            obj_.build(child_)
            self.module.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'consequence':
            obj_ = consequence.factory()
            obj_.build(child_)
            self.consequence.append(obj_)
# end class exploit


class vulnerability(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=''):
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if vulnerability.subclass:
            return vulnerability.subclass(*args_, **kwargs_)
        else:
            return vulnerability(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='vulnerability', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='vulnerability')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='vulnerability'):
        if self.id is not None:
            outfile.write(' id=%s' % (self.format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='vulnerability'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='vulnerability'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.id is not None:
            showIndent(outfile, level)
            outfile.write('id = "%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('id'):
            self.id = attrs.get('id').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class vulnerability


class module(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, clsname=None, clsid=None, valueOf_=''):
        self.clsname = _cast(None, clsname)
        self.clsid = _cast(None, clsid)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if module.subclass:
            return module.subclass(*args_, **kwargs_)
        else:
            return module(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_clsname(self): return self.clsname
    def set_clsname(self, clsname): self.clsname = clsname
    def get_clsid(self): return self.clsid
    def set_clsid(self, clsid): self.clsid = clsid
    def getValueOf_(self): return self.valueOf_
    def setValueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def export(self, outfile, level, namespace_='', name_='module', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='module')
        if self.hasContent_():
            outfile.write('>')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='module'):
        if self.clsname is not None:
            outfile.write(' clsname=%s' % (self.format_string(quote_attrib(self.clsname).encode(ExternalEncoding), input_name='clsname'), ))
        if self.clsid is not None:
            outfile.write(' clsid=%s' % (self.format_string(quote_attrib(self.clsid).encode(ExternalEncoding), input_name='clsid'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='module'):
        if self.valueOf_.find('![CDATA') > -1:
            value=quote_xml('%s' % self.valueOf_)
            value=value.replace('![CDATA','<![CDATA')
            value=value.replace(']]',']]>')
            outfile.write(value)
        else:
            outfile.write(quote_xml('%s' % self.valueOf_))
    def hasContent_(self):
        if (
            self.valueOf_
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='module'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.clsname is not None:
            showIndent(outfile, level)
            outfile.write('clsname = "%s",\n' % (self.clsname,))
        if self.clsid is not None:
            showIndent(outfile, level)
            outfile.write('clsid = "%s",\n' % (self.clsid,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        self.valueOf_ = ''
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('clsname'):
            self.clsname = attrs.get('clsname').value
        if attrs.get('clsid'):
            self.clsid = attrs.get('clsid').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.TEXT_NODE:
            self.valueOf_ += child_.nodeValue
        elif child_.nodeType == Node.CDATA_SECTION_NODE:
            self.valueOf_ += '![CDATA['+child_.nodeValue+']]'
# end class module


class consequence(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, type_=None, additionalData=None):
        self.type_ = _cast(None, type_)
        if additionalData is None:
            self.additionalData = []
        else:
            self.additionalData = additionalData
    def factory(*args_, **kwargs_):
        if consequence.subclass:
            return consequence.subclass(*args_, **kwargs_)
        else:
            return consequence(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_additionalData(self): return self.additionalData
    def set_additionalData(self, additionalData): self.additionalData = additionalData
    def add_additionalData(self, value): self.additionalData.append(value)
    def insert_additionalData(self, index, value): self.additionalData[index] = value
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def export(self, outfile, level, namespace_='', name_='consequence', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='consequence')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='consequence'):
        if self.type_ is not None:
            outfile.write(' type=%s' % (self.format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='consequence'):
        for additionalData_ in self.additionalData:
            showIndent(outfile, level)
            outfile.write('<%sadditionalData>%s</%sadditionalData>\n' % (namespace_, self.format_string(quote_xml(additionalData_).encode(ExternalEncoding), input_name='additionalData'), namespace_))
    def hasContent_(self):
        if (
            self.additionalData
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='consequence'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        if self.type_ is not None:
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('additionalData=[\n')
        level += 1
        for additionalData_ in self.additionalData:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(additionalData_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        if attrs.get('type'):
            self.type_ = attrs.get('type').value
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'additionalData':
            additionalData_ = ''
            for text__content_ in child_.childNodes:
                additionalData_ += text__content_.nodeValue
            self.additionalData.append(additionalData_)
# end class consequence


class classifications(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, classification=None):
        if classification is None:
            self.classification = []
        else:
            self.classification = classification
    def factory(*args_, **kwargs_):
        if classifications.subclass:
            return classifications.subclass(*args_, **kwargs_)
        else:
            return classifications(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_classification(self): return self.classification
    def set_classification(self, classification): self.classification = classification
    def add_classification(self, value): self.classification.append(value)
    def insert_classification(self, index, value): self.classification[index] = value
    def export(self, outfile, level, namespace_='', name_='classifications', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='classifications')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='classifications'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='classifications'):
        for classification_ in self.classification:
            classification_.export(outfile, level, namespace_, name_='classification')
    def hasContent_(self):
        if (
            self.classification
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='classifications'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('classification=[\n')
        level += 1
        for classification_ in self.classification:
            showIndent(outfile, level)
            outfile.write('model_.classification(\n')
            classification_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'classification':
            obj_ = classification.factory()
            obj_.build(child_)
            self.classification.append(obj_)
# end class classifications


class classification(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, antivirus=None, urlbls=None):
        if antivirus is None:
            self.antivirus = []
        else:
            self.antivirus = antivirus
        if urlbls is None:
            self.urlbls = []
        else:
            self.urlbls = urlbls
    def factory(*args_, **kwargs_):
        if classification.subclass:
            return classification.subclass(*args_, **kwargs_)
        else:
            return classification(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_antivirus(self): return self.antivirus
    def set_antivirus(self, antivirus): self.antivirus = antivirus
    def add_antivirus(self, value): self.antivirus.append(value)
    def insert_antivirus(self, index, value): self.antivirus[index] = value
    def get_urlbls(self): return self.urlbls
    def set_urlbls(self, urlbls): self.urlbls = urlbls
    def add_urlbls(self, value): self.urlbls.append(value)
    def insert_urlbls(self, index, value): self.urlbls[index] = value
    def export(self, outfile, level, namespace_='', name_='classification', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='classification')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='classification'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='classification'):
        for antivirus_ in self.antivirus:
            antivirus_.export(outfile, level, namespace_, name_='antivirus')
        for urlbls_ in self.urlbls:
            urlbls_.export(outfile, level, namespace_, name_='urlbls')
    def hasContent_(self):
        if (
            self.antivirus or
            self.urlbls
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='classification'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('antivirus=[\n')
        level += 1
        for antivirus_ in self.antivirus:
            showIndent(outfile, level)
            outfile.write('model_.antivirus(\n')
            antivirus_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('urlbls=[\n')
        level += 1
        for urlbls_ in self.urlbls:
            showIndent(outfile, level)
            outfile.write('model_.urlbls(\n')
            urlbls_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'antivirus':
            obj_ = antivirus.factory()
            obj_.build(child_)
            self.antivirus.append(obj_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'urlbls':
            obj_ = urlbls.factory()
            obj_.build(child_)
            self.urlbls.append(obj_)
# end class classification


class antivirus(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, engine=None, version=None, datVersion=None, timestamp=None, result=None):
        if engine is None:
            self.engine = []
        else:
            self.engine = engine
        if version is None:
            self.version = []
        else:
            self.version = version
        if datVersion is None:
            self.datVersion = []
        else:
            self.datVersion = datVersion
        if timestamp is None:
            self.timestamp = []
        else:
            self.timestamp = timestamp
        if result is None:
            self.result = []
        else:
            self.result = result
    def factory(*args_, **kwargs_):
        if antivirus.subclass:
            return antivirus.subclass(*args_, **kwargs_)
        else:
            return antivirus(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_engine(self): return self.engine
    def set_engine(self, engine): self.engine = engine
    def add_engine(self, value): self.engine.append(value)
    def insert_engine(self, index, value): self.engine[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def add_version(self, value): self.version.append(value)
    def insert_version(self, index, value): self.version[index] = value
    def get_datVersion(self): return self.datVersion
    def set_datVersion(self, datVersion): self.datVersion = datVersion
    def add_datVersion(self, value): self.datVersion.append(value)
    def insert_datVersion(self, index, value): self.datVersion[index] = value
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def add_timestamp(self, value): self.timestamp.append(value)
    def insert_timestamp(self, index, value): self.timestamp[index] = value
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def add_result(self, value): self.result.append(value)
    def insert_result(self, index, value): self.result[index] = value
    def export(self, outfile, level, namespace_='', name_='antivirus', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='antivirus')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='antivirus'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='antivirus'):
        for engine_ in self.engine:
            showIndent(outfile, level)
            outfile.write('<%sengine>%s</%sengine>\n' % (namespace_, self.format_string(quote_xml(engine_).encode(ExternalEncoding), input_name='engine'), namespace_))
        for version_ in self.version:
            showIndent(outfile, level)
            outfile.write('<%sversion>%s</%sversion>\n' % (namespace_, self.format_string(quote_xml(version_).encode(ExternalEncoding), input_name='version'), namespace_))
        for datVersion_ in self.datVersion:
            showIndent(outfile, level)
            outfile.write('<%sdatVersion>%s</%sdatVersion>\n' % (namespace_, self.format_string(quote_xml(datVersion_).encode(ExternalEncoding), input_name='datVersion'), namespace_))
        for timestamp_ in self.timestamp:
            showIndent(outfile, level)
            outfile.write('<%stimestamp>%s</%stimestamp>\n' % (namespace_, self.format_string(quote_xml(timestamp_).encode(ExternalEncoding), input_name='timestamp'), namespace_))
        for result_ in self.result:
            showIndent(outfile, level)
            outfile.write('<%sresult>%s</%sresult>\n' % (namespace_, self.format_string(quote_xml(result_).encode(ExternalEncoding), input_name='result'), namespace_))
    def hasContent_(self):
        if (
            self.engine or
            self.version or
            self.datVersion or
            self.timestamp or
            self.result
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='antivirus'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('engine=[\n')
        level += 1
        for engine_ in self.engine:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(engine_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('version=[\n')
        level += 1
        for version_ in self.version:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(version_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('datVersion=[\n')
        level += 1
        for datVersion_ in self.datVersion:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(datVersion_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('timestamp=[\n')
        level += 1
        for timestamp_ in self.timestamp:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(timestamp_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('result=[\n')
        level += 1
        for result_ in self.result:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(result_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'engine':
            engine_ = ''
            for text__content_ in child_.childNodes:
                engine_ += text__content_.nodeValue
            self.engine.append(engine_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'version':
            version_ = ''
            for text__content_ in child_.childNodes:
                version_ += text__content_.nodeValue
            self.version.append(version_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'datVersion':
            datVersion_ = ''
            for text__content_ in child_.childNodes:
                datVersion_ += text__content_.nodeValue
            self.datVersion.append(datVersion_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timestamp':
            timestamp_ = ''
            for text__content_ in child_.childNodes:
                timestamp_ += text__content_.nodeValue
            self.timestamp.append(timestamp_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'result':
            result_ = ''
            for text__content_ in child_.childNodes:
                result_ += text__content_.nodeValue
            self.result.append(result_)
# end class antivirus


class urlbls(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, urlbl=None):
        if urlbl is None:
            self.urlbl = []
        else:
            self.urlbl = urlbl
    def factory(*args_, **kwargs_):
        if urlbls.subclass:
            return urlbls.subclass(*args_, **kwargs_)
        else:
            return urlbls(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_urlbl(self): return self.urlbl
    def set_urlbl(self, urlbl): self.urlbl = urlbl
    def add_urlbl(self, value): self.urlbl.append(value)
    def insert_urlbl(self, index, value): self.urlbl[index] = value
    def export(self, outfile, level, namespace_='', name_='urlbls', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='urlbls')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='urlbls'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='urlbls'):
        for urlbl_ in self.urlbl:
            urlbl_.export(outfile, level, namespace_, name_='urlbl')
    def hasContent_(self):
        if (
            self.urlbl
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='urlbls'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('urlbl=[\n')
        level += 1
        for urlbl_ in self.urlbl:
            showIndent(outfile, level)
            outfile.write('model_.urlbl(\n')
            urlbl_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'urlbl':
            obj_ = urlbl.factory()
            obj_.build(child_)
            self.urlbl.append(obj_)
# end class urlbls


class urlbl(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, bl=None, timestamp=None, result=None):
        if bl is None:
            self.bl = []
        else:
            self.bl = bl
        if timestamp is None:
            self.timestamp = []
        else:
            self.timestamp = timestamp
        if result is None:
            self.result = []
        else:
            self.result = result
    def factory(*args_, **kwargs_):
        if urlbl.subclass:
            return urlbl.subclass(*args_, **kwargs_)
        else:
            return urlbl(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_bl(self): return self.bl
    def set_bl(self, bl): self.bl = bl
    def add_bl(self, value): self.bl.append(value)
    def insert_bl(self, index, value): self.bl[index] = value
    def get_timestamp(self): return self.timestamp
    def set_timestamp(self, timestamp): self.timestamp = timestamp
    def add_timestamp(self, value): self.timestamp.append(value)
    def insert_timestamp(self, index, value): self.timestamp[index] = value
    def get_result(self): return self.result
    def set_result(self, result): self.result = result
    def add_result(self, value): self.result.append(value)
    def insert_result(self, index, value): self.result[index] = value
    def export(self, outfile, level, namespace_='', name_='urlbl', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        self.exportAttributes(outfile, level, namespace_, name_='urlbl')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, namespace_='', name_='urlbl'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='urlbl'):
        for bl_ in self.bl:
            showIndent(outfile, level)
            outfile.write('<%sbl>%s</%sbl>\n' % (namespace_, self.format_string(quote_xml(bl_).encode(ExternalEncoding), input_name='bl'), namespace_))
        for timestamp_ in self.timestamp:
            showIndent(outfile, level)
            outfile.write('<%stimestamp>%s</%stimestamp>\n' % (namespace_, self.format_string(quote_xml(timestamp_).encode(ExternalEncoding), input_name='timestamp'), namespace_))
        for result_ in self.result:
            showIndent(outfile, level)
            outfile.write('<%sresult>%s</%sresult>\n' % (namespace_, self.format_string(quote_xml(result_).encode(ExternalEncoding), input_name='result'), namespace_))
    def hasContent_(self):
        if (
            self.bl or
            self.timestamp or
            self.result
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='urlbl'):
        level += 1
        self.exportLiteralAttributes(outfile, level, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('bl=[\n')
        level += 1
        for bl_ in self.bl:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(bl_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('timestamp=[\n')
        level += 1
        for timestamp_ in self.timestamp:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(timestamp_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('result=[\n')
        level += 1
        for result_ in self.result:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(result_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node_):
        attrs = node_.attributes
        self.buildAttributes(attrs)
        for child_ in node_.childNodes:
            nodeName_ = child_.nodeName.split(':')[-1]
            self.buildChildren(child_, nodeName_)
    def buildAttributes(self, attrs):
        pass
    def buildChildren(self, child_, nodeName_):
        if child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'bl':
            bl_ = ''
            for text__content_ in child_.childNodes:
                bl_ += text__content_.nodeValue
            self.bl.append(bl_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'timestamp':
            timestamp_ = ''
            for text__content_ in child_.childNodes:
                timestamp_ += text__content_.nodeValue
            self.timestamp.append(timestamp_)
        elif child_.nodeType == Node.ELEMENT_NODE and \
            nodeName_ == 'result':
            result_ = ''
            for text__content_ in child_.childNodes:
                result_ += text__content_.nodeValue
            self.result.append(result_)
# end class urlbl


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def parse(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = urls.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="urls", 
        namespacedef_='')
    return rootObj


def parseString(inString):
    doc = minidom.parseString(inString)
    rootNode = doc.documentElement
    rootObj = urls.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="urls",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = minidom.parse(inFileName)
    rootNode = doc.documentElement
    rootObj = urls.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from xml_output import *\n\n')
    sys.stdout.write('import xml_output as model_\n\n')
    sys.stdout.write('rootObj = model_.urls(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_="urls")
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()

